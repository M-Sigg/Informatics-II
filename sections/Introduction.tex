\subsection{Algorithms}

\subsection{Sorting}
Problem specification
\begin{itemize}
    \item Input: s sequence of $n$ numbers $A=[a_1,a_2,\cdots,a_n]$
    \item Output: a permutation (reordering) $]b_1,b_2,\cdots,b_n]$ of the input sequence such that $b_1 \leq b_2 \leq \cdots \leq b_n$
\end{itemize}

\subsubsection{Bubble Sort}
Rough idea:
\begin{itemize}
    \item Scan sequence and swap unsorted adjacent elements
    \item Repeat the procedure until sequence is actually sorted
\end{itemize}

\begin{center}
\begin{minipage}{0.4\textwidth}
\begin{algorithm}[H]
\caption{BubbleSort(A)}
\For{$i = n$ \KwTo $2$}{
    \For{$j = 2$ \KwTo $i$}{
        \If{$A[j] < A[j-1]$}{
            $t = A[j]$\;
            $A[j] = A[j-1]$\;
            $A[j-1] = t$\;
        }
    }
}
\end{algorithm}
\end{minipage}
\end{center}

Basic properties: 
\begin{itemize}
    \item Number of comparisons:
    \[
    C = \sum_{i=2}^n(i-1)=\sum_{i=1}^{n-1}=\frac{(n-1)n}{2}=\frac{n^2-n}{2}
    \]
    \item Number of moves:
    \begin{align*}
        &Mmin=0 \\
        &Mmax = \sum_{i=2}^n 3(i-1) = \frac{3n(n-1)}{2} = \frac{3n^2-3n}{2}
    \end{align*}
\end{itemize}



\subsubsection{Selection Sort}
Rough idea: 
\begin{itemize}
    \item Select smallest element and swap with 1st element
    \item Repeat the procedure on remaining unsorted sequence
\end{itemize}

\begin{center}
\begin{minipage}{0.6\textwidth} % Adjust the width as needed
\centering % Center the content within the minipage
\begin{algorithm}[H]
\caption{SelectionSort(A)}
\For{$i = 1$ \KwTo $n-1$}{
    $k = i$\;
    \For{$j = i+1$ \KwTo $n$}{
        \If{$A[j] < A[k]$}{
            $k = j$\;
        }
    }
    exchange $A[i]$ and $A[k]$\;
}
\end{algorithm}
\end{minipage}
\end{center}

Basic properties:
\begin{itemize}
    \item Number of comparisons:
    \[
    C= \sum_{i=1}^{n-1} i = \frac{n^2-n}{2}
    \]
    \item Number of moves: (3 because 1 swap is 3 operations) \[
    M= \sum_{i=1}^{n-1} 3=3(n-1)=3n-3
    \]
\end{itemize}

\subsubsection{Insertion Sort}
Rough idea:
\begin{itemize}
    \item Take first element and consider it as (sorted) sequence
    \item Continue taking elements and inserting into right place
\end{itemize}

\begin{center}
\begin{minipage}{0.6\textwidth} % Adjust the width as needed
\centering % Center the content within the minipage
\begin{algorithm}[H]
\caption{InsertionSort(A)}
\For{$i = 2$ \KwTo $n$}{
    $j = i-1$\;
    $t=A[i]$\;
    \While{$j \geq 1 \land t < A[j]$}{
        $A[j+1] = A[j]$\;
        $j=j-1$\;
    }
   $ A[j+1]=t$\;
}
\end{algorithm}
\end{minipage}
\end{center}

Basic properties:
\begin{itemize}
    \item Number of comparisons:
    \begin{align*}
        &Cmin = \sum_{i=2}^n 1 = n-1 \\
        &Cmax = \sum_{i=2}^n (i-1)=\frac{n^2-n}{2}
    \end{align*}
    \item Number of moves:
    \begin{align*}
        &Mmin = \sum_{i=2}^n 2 = 2(n-1) = 2n-2 \\
        &Mmax = \sum_{i=2}^n (i+1)=\frac{n^2 + 3n-4}{2}
    \end{align*}
\end{itemize}

\subsection{Recursion}

\subsection{Summary}
\begin{itemize}
    \item Algorithmic problem:
    \begin{itemize}
        \item An algorithm transforms input data into output data
        \item Precisely specify \textbf{input} and \textbf{output}; consider special cases; work out representative examples
        \item A first step is to come up with a simple plan
        \item Split or revise complex plans until they get simple
    \end{itemize}
    \item Sorting algorithms
    \begin{itemize}
        \item A classical and representative algorithmic problem
        \item Initialization and conditions in loop are important
        \item Make sure you get details of loops \textbf{correct by design}. Avoid trial and error
    \end{itemize}
    \item Recursive algorithms
    \begin{itemize}
        \item Recursion is an important algorithmic technique
        \item Practice the design of recursive algorithms
        \item Consider \textbf{special cases}: termination, the first couple of recursive calls
    \end{itemize}
\end{itemize}